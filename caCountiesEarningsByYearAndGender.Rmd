---
title: "Earnings by California County Employees"
subtitle: "An analysis of public available data"
author: "Moises Evangelista"
date: "`r Sys.Date()`"
output:
  pdf_document:
    fig_width: 7
    fig_height: 9
    fig_caption: true
    fig_crop: false
fontsize: 11pt
header-includes:
- \usepackage{hyperref, fancyhdr, pdflscape}
- \hypersetup{colorlinks,urlcolor=blue}
- \pagestyle{fancy}
- \fancyhead[CO,CE]{\fontsize{10}{12} \selectfont Earnings by California County Employees}
---


# Introduction

This report tries to mimic the report titled [County Pay Practices](https://www.auditor.ca.gov/pdfs/reports/2015-132.pdf), Report 2015-132. County Pay Practices report was created by the California State Auditor and it sheds light in the wage gap between females and male employees employed by California counties.

This report uses publicly available data to shed more light on the report created by the California State Auditor.  The data the data source for this report is from [transparentcalifornia.com](http://transparentcalifornia.com)

\newpage

```{r setup, include=FALSE}

rm(list=ls(all=TRUE)) #start with empty workspace

startTime <- Sys.time() # start the clock

knitr::opts_chunk$set(cache = TRUE, echo = FALSE, message = FALSE, warning = FALSE, include = FALSE)

setwd("~/GitHub/Earnings-Public-Use-File-2006") # set the working directory
list.files()

# load("earningsData.RData")
```


```{r loadpackages}

library(data.table)
library(dplyr)
library(tidyr)
library(stringr)
library(babynames)
# library(genderizeR)
library(descr)
library(ggplot2)
library(scales)
library(tm)
library(pander)

```

```{r importdata, cache = TRUE}

# set the years to download the data

DaysSequence <- seq(as.Date("2013/1/1"), as.Date("2014/1/1"), "years")

Years <- as.numeric(format(DaysSequence,"%Y"))

n <- length(DaysSequence) 

# pre-allocate list to fill

links  = ""

# build the links

for(i in 1:n){
  print(i) # keep track of what the function is up to
  links[[i]] <- paste0("http://transparentcalifornia.com/export/",
                       Years[i],
                      "-counties.csv")
}

all_tables <- vector("list", length = (length(links)))

# import the data

for (i in 1:length(links)) {
  # print(i)
  # error handling - skips to next URL if it gets an error
  result <- try(
    # all_tables[[i]] <-  read.csv(links[i], 
    all_tables[[i]] <-  data.table::fread(links[i], 
                                 header = TRUE,
                                 showProgress = FALSE)
  ); if (class(result) == "try-error") next;
}

rm(result)

# create one dataframe from the downloaded data

CountyData <- plyr::ldply(all_tables, data.frame)

# remove recods where the name is not provided

namesToRemove <- c("Not Provided|Redacted Name Redacted Name|Redacted Redacted|REDACTED REDACTED|Xxx Xxx|Undisclosed|Redact Redact|Undisclosed Undisclosed|Name Withheld Name Withheld|NAME REDACTED|REDACTED|Safety Personnel - Name Redacted|NAME WITHHELD|Exempt From Disclosure|Employee Name|Exempt from Discloser")

CountyData <- CountyData %>%
  filter(!grepl(namesToRemove,
                Employee.Name, ignore.case = TRUE)) %>% # remove names that are not 'names'
  filter(Total.Pay...Benefits > 0) %>%                 # get only positive pay   
  droplevels()

summary(CountyData)

listOfNames <- babynames

# determine the proportion of male female names by name

listOfNamesByGender <- listOfNames %>%
  dplyr::select( name, sex, n) %>% 
  group_by(sex, name) %>% 
  summarise(TotalCount = sum(n)) %>%
  spread(  sex, TotalCount ) %>%
  mutate(TotalCountAllYears =  rowSums(.[2:3], na.rm = TRUE),
         FemalePercent = F/TotalCountAllYears,
         MalePercent = M/TotalCountAllYears) %>%
  dplyr::select(name, FemalePercent, MalePercent)

listOfNamesByGender %>% filter(MalePercent <.5 &
                                 MalePercent >.45)

# remove Jr, sr. II, III, IV and 
# determine names that are both male and female

listWordsToRemove <- c("sr", "jr","ii", "iii", "iv")

CountyDataWithGender <- CountyData %>%
  # filter(Employee.Name == "Sevilla Iii Conrado") %>%
  mutate(CleanEmpName = tolower(Employee.Name),
         CleanEmpName = removeWords(CleanEmpName, listWordsToRemove),
         CleanEmpName = sub("\\.","", CleanEmpName) ,
         CleanEmpName = gsub('\\b\\w{1,1}\\b','',CleanEmpName),   # remove one character letters
         CleanEmpName = trimws(CleanEmpName),
         name = ifelse(grepl(",", CleanEmpName), sub('.*,\\s*', '', CleanEmpName), CleanEmpName),
         name =  word(name, 1),
         # name = tolower(name),
         name = gsub("\\b(\\w)", "\\U\\1", name, perl = TRUE),  # capitalize the fist name
         name = gsub("[^[:alnum:] ]", "", name)) %>% # head() %>%
  as.data.frame() %>%
  left_join(listOfNamesByGender) %>%
  mutate(FinalGender = ifelse(is.na(FemalePercent) & is.na( MalePercent),"bothMissing",
                              ifelse(is.na(FemalePercent) & !is.na( MalePercent),"MaleLikely", 
                                     ifelse(!is.na(FemalePercent) & is.na( MalePercent),"FemaleLikely", 
                                            ifelse( FemalePercent > MalePercent, "FemaleLikely", "MaleLikely" )))))

NamesUnmatched <- CountyDataWithGender %>%
  filter(FinalGender == "bothMissing") %>%
  group_by(name) %>%
  summarise(count = n()) %>%
  arrange(desc(count))

set.seed(10)

UnmatchedKernCounty <- CountyDataWithGender %>% filter(Agency == "Kern County",
                                FinalGender == "bothMissing") %>%
  select(Employee.Name, FinalGender ) %>%
  sample_n (5) %>%
  mutate(Type = "Unmatched Name")

MatchedKernCounty <- CountyDataWithGender %>% filter(Agency == "Kern County",
                                FinalGender != "bothMissing") %>%
  select(Employee.Name, FinalGender ) %>%
  sample_n (5) %>%
  mutate(Type = "Matched Name") %>%
  full_join(UnmatchedKernCounty)

# save.image(file = "earningsData.RData")

```


```{r reviewCleanedData}

# review names that are unknown

MissingNames <- CountyDataWithGender %>% 
  filter(FinalGender == "bothMissing") %>%
  group_by(Agency, Employee.Name, name) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  arrange(desc(count))

tableCounts <- with(CountyDataWithGender, table(Agency, FinalGender, useNA = "ifany"))

tableCounts

propTable <- prop.table(tableCounts, 1)

t <- CountyDataWithGender %>% filter(Agency == "Kern County") %>%
  group_by(FinalGender, Job.Title) %>%
  summarise(count = n()) %>%
  arrange(desc(count))

# with(t, table(Job.Title, FinalGender))

rm(list = ls(pattern = "listOfNames"))

```

\newpage


# Empirical Analysis

The data from transparentcalifornia.com was downloaded for years 2013 and  2014 (the data for year 2015 is incomplete as of `r Sys.Date()`). The data includes employee names but it lacks employee gender. To overcome the gender data not being included a processed was used to match the names to another list that is composed of names and gender. A list of names that includes gender was extracted from the R package `babynames`.  'The baby names list is composed from US baby names provided by the SSA. This package contains all names used for at least 5 children of either sex'. [see this more more information](https://cran.r-project.org/web/packages/babynames/babynames.pdf).

The names from the county data were generally composed in one of two formats.  The first format was `FIRST LAST`, the second format was `LAST, FIRST`.

The county data was processed by extracting the first names for each record. The data from the R package was summarized and names were given a proportion of usage e.g. Alexy was classified as female and as was Adel. Some names are almost exclusively used by females e.g. Therese or Annabelle and some are almost exclusively used by males e.g. Rodrigo or Mauricio. Some names are used by male and females almost equally e.g. Alexy or Adel. 

Names from the county data were matched with the list of names with gender and the likely gender was then selected for each name. After the name matching processes some names were left unmatched e.g.Mcheko or SuiKwong.

Also, For this report the median was used because it is less prone to be skewed by total pay observations that are too high or too low especially since the total earnings have long tails e.i. some records have cents and some records have over a million of total earnings.


### Data issues

This analysis uses each row as if it was a unique worker and this method this creates some issues. Some workers may be employees in one department with a certain title e.g. Program Analyst and then promote to another title within the department e.g. Information Systems Analyst.  In this situations the same worker may appear twice in the data in the same year.  In addition, some workers may start working for the county for part of the year due to being a new hire or leaving county employment due to retirement, death, or employment in the private sector. This situations may impact the wages per employee.

Some salaries include back pay and court settlement payments, which make total pay increase and thus skew the data for some records.

Suggestions to mitigate these situations and get a better idea of county pay is to include a unique identifier by worker (it does not have to be the employee number), and include the number of hours a worker was paid in the year and separate the payments due to court settlements. In addition, the names to have a consistent format either first name first or first name after a comman.

\footnotesize

```{r tableMatchedRecordNames, include=TRUE}

panderOptions('digits', 1)
panderOptions('round', c(2,2,2,2))
panderOptions('keep.trailing.zeros', TRUE)
panderOptions('decimal.mark', ".")
panderOptions('big.mark', ",")
panderOptions('table.split.cells', c(35, 35, 10, 10, 10))

pander(propTable,
       split.table = Inf,
       caption = "The table below shows the percent of names matched to males or females for years 2013 and 2014. Kern County has the highest percent of unmatched names because their name structure is in disarray")

```

\normalsize

\newpage

For this analysis the data from Kern County represented a major concern since it does not follow any of the two name formats used by the other counties. 

\footnotesize

```{r tableKernCountNamesMatchedSample, include=TRUE}

panderOptions('table.alignment.default',
     function(df) ifelse(sapply(df, is.numeric), 'right', 'left'))
panderOptions('digits', 1)
panderOptions('round', c(2,2,2,2))
panderOptions('keep.trailing.zeros', TRUE)
panderOptions('decimal.mark', ".")
panderOptions('big.mark', ",")
panderOptions('table.split.cells', c(10, 65, 55, 55))

pander(MatchedKernCounty,
       split.table = Inf,
       caption = "Sample of five records that were matched and five records that were unmatched from Kern County data. For some records the names are scrabbled, first name appears first and sometimes it appears in the middle of the name, and commas are missing. In addition, Name initials and name suffix add to the complexity of Kern County data.")

```


\normalsize

```{r calMedianPay}
# calc the median pay by county

CountyDataWithGender <- CountyDataWithGender %>%
  group_by(Agency, Year) %>%
  mutate(medianPay = median(Total.Pay...Benefits),  # this median is by county for all employees
         AboveOrBelowMedianPay = ifelse(Total.Pay...Benefits >=  medianPay ,"above","below"))

CountyDataWithGender <- CountyDataWithGender %>%
  filter(FinalGender != "bothMissing") %>%
  group_by(Agency, Year, FinalGender) %>%
  mutate(medianPayByGender = median(Total.Pay...Benefits))  # this median is by county and gender

```

\newpage

## Median pay 

To measure the gap in pay by gender, it is useful to know the number of employees who are above and below the median for each county. So the median pay was extracted, rather than the average, by county and by year. The records where then grouped into above or below the median and a [Chi-squared test](https://en.wikipedia.org/wiki/Chi-squared_test) was complete by county.  For most counties the number of records classified as female and that are above the median is lower that what is expected and the difference is statistically significant (it's unlikely that occurred by chance).



```{r pressure, echo=FALSE}

CountyDataWithGender %>%
  group_by(Agency, AboveOrBelowMedianPay,FinalGender) %>%
  summarise(count = n()) %>%
  spread(FinalGender, count)

testData <- CountyDataWithGender %>%
  dplyr::select(Agency, Year, FinalGender, AboveOrBelowMedianPay) %>%
  mutate(AgencyYear = paste0(Agency,"-",Year)) %>% droplevels()

# to chi square tests for each county and year

doExpectedValues = function(sel_name) {
  dum = filter(testData, AgencyYear == sel_name) %>% droplevels()

   ct <-  CrossTable(dum$FinalGender, dum$AboveOrBelowMedianPay)
   ctO <- ct$CST$expected
}

testdataExpected <- lapply(unique(testData$AgencyYear), doExpectedValues)

Category_names <- unique(testData$AgencyYear)

# assign  names to list of tables
names(testdataExpected) <- Category_names

testdataExpectedFinal <- testdataExpected %>% # head(1000) %>%
  plyr::ldply(data.frame) %>%
  dplyr::select(AgencyYear = 1, above, below) %>%
  mutate(FinalGender = rep(c("FemaleLikely","MaleLikely"), length(Category_names))) %>%
  gather(AboveOrBelowMedianPay, ExpectedCount, -c(AgencyYear, FinalGender))

doExpectedPValues = function(sel_name) {
  dum = filter(testData, AgencyYear == sel_name) %>% droplevels()

   ct <-  CrossTable(dum$FinalGender, dum$AboveOrBelowMedianPay)
   ctO <- ct$CST$p.value
}

testDataPvalues <- lapply(unique(testData$AgencyYear), doExpectedPValues)

# assign names to list of tables
names(testDataPvalues) <- Category_names

testDataPvaluesFinal <- testDataPvalues %>% # head(1000) %>%
  plyr::ldply(data.frame) %>%
  dplyr::select(AgencyYear = 1, pvalue = 2)  %>%
  mutate( pvalue = ifelse(pvalue ==  0,
                          paste0("**",formatC(pvalue, 1, width = 1),"**"),
                          ifelse(pvalue > 0 & pvalue <= 0.05,
                                 paste0("**",formatC(pvalue, 4),"**"),
                                 formatC(pvalue, 4))))
  #mutate(pvalue = trunc(pvalue, 4))

```


\footnotesize

```{r tablePvalues2014ByCounty, include=TRUE}

t <-  CountyDataWithGender %>%
  mutate(AgencyYear = paste0(Agency,"-",Year)) %>%
  group_by(AgencyYear, AboveOrBelowMedianPay, FinalGender) %>%
  summarise(ActualCount = n()) %>%
  left_join(testdataExpectedFinal) %>%
  left_join(testDataPvaluesFinal) %>%
  ungroup() %>%
  separate(AgencyYear, c("Agency", "Year"), "-") %>%
  filter(Year == "2014",
         AboveOrBelowMedianPay == "above",
         FinalGender == "FemaleLikely") %>%
  dplyr::select(Agency,  ActualCount, ExpectedCount , pvalue) %>%
  add_rownames( var = "ID") %>%
  droplevels() 

panderOptions('digits', 1)
panderOptions('round', c(0,0,0,0))
panderOptions('keep.trailing.zeros', TRUE)
panderOptions('decimal.mark', ".")
panderOptions('big.mark', ",")
panderOptions('table.split.cells', c(35, 35, 10, 10, 10))

pander(t,
       split.table = Inf,
       caption = "Expected and observed females counts over the median pay by county in 2014. County where the p-value is highlighted show a statistical significant difference between expected and observed counts")

```


\normalsize

```{r plotTopCounties, fig.width = 6, fig.height = 8, fig.fullwidth = TRUE, fig.cap= "Top 10 counties in 2014 (representing about 70% of total records) broken down by expected and actual counts of those above and below the median total pay.", message = FALSE, warning = FALSE, include = TRUE, eval = TRUE}

yearFilter = "2014"

Top10ByYear2014 <- CountyDataWithGender %>%
  filter(FinalGender != "bothMissing") %>%
  mutate(AgencyYear = paste0(Agency,"-",Year)) %>%
  group_by(AgencyYear) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  separate(AgencyYear, c("Agency", "Year"), "-") %>%
  #group_by(Agency, Year) %>%
  filter(Year == yearFilter) %>%
  arrange(desc(count)) %>%
  top_n(10)

t <- CountyDataWithGender %>%
  filter(FinalGender != "bothMissing") %>%
  mutate(AgencyYear = paste0(Agency,"-",Year)) %>%
  group_by(AgencyYear, AboveOrBelowMedianPay, FinalGender) %>%
  summarise(ActualCount = n()) %>%
  left_join(testdataExpectedFinal) %>%
  ungroup() %>%
  separate(AgencyYear, c("Agency", "Year"), "-") %>%
  gather(Metric, value, -c(Agency, Year, AboveOrBelowMedianPay, FinalGender)) %>%
  right_join(Top10ByYear2014)

ggplot(t, aes(value, Metric)) +
  geom_point( aes(colour = FinalGender,
                  shape = AboveOrBelowMedianPay),
              alpha = 3/4,
              size = 2) + 
  #facet_wrap(~Agency, scales = "free_x") +
  facet_grid(Agency ~ ., scales = "free_x",  space = "free") + 
  scale_x_continuous(name = "Number of employees (log scale)",
                     trans = log_trans(), 
                     breaks = c(200,2000,10000,20000),
                     labels = comma_format()) +
  theme(        axis.text.x = element_text(size = 5, 
                                           angle = 00,
                                           color = "black", 
                                           hjust = 0),
                axis.text.y  = element_text(size = 5, 
                                            angle = 00,
                                            color = "black", 
                                            hjust = 0),
                strip.text.y = element_text(size = 10,
                                            angle = 0),
                legend.position = "top",
                legend.margin = unit(0, "cm"),
                plot.margin = unit(c(0,0,0,0), "cm"))   #T, R, B, L)

```

\newpage

\footnotesize

```{r FemalePayAsPercentOfMale, include=TRUE}

yearFilter = "2014"

WageRatios <- CountyDataWithGender %>%
  filter(Year == yearFilter) %>%
  select(Agency, FinalGender, medianPayByGender) %>%
  unique () %>%
  group_by(Agency) %>%
  spread(FinalGender, medianPayByGender) %>%
  mutate(FamaleToMaleRatioWage = FemaleLikely / MaleLikely,
         FamaleToMaleRatioWage = ifelse( FamaleToMaleRatioWage >=.9,
                        paste0("**",formatC(FamaleToMaleRatioWage, 4),"**"),
                        formatC(FamaleToMaleRatioWage, 4)
                        )) %>%
  select(Agency:FamaleToMaleRatioWage)

panderOptions('digits', c(1,2,2,2))
panderOptions('round', c(0,0,0,0,0))
panderOptions('keep.trailing.zeros', TRUE)
panderOptions('decimal.mark', ".")
panderOptions('big.mark', ",")
panderOptions('table.split.cells', c(35, 35, 35, 15, 15,10))

pander(WageRatios,
       split.table = Inf,
       caption = "Wage ratio by county for 2014, Merced and Lassen counties ratio is over 1. Pay ratios for counties where the ratio is close or over 1 are in bold font in column 'FamaleToMaleRatioWage'.")

```

\normalsize


```{r plotDensityHistogram, fig.width = 7, fig.height = 9,  eval=TRUE, include=TRUE, fig.cap= "Top 10 counties in 2014 (representing about 70% of total records) broken down gender and county. It excludes records with over one million or less than 100 dollars total pay.", message = FALSE, warning = FALSE, include=TRUE} 

yearFilter = "2014"

Top10ByYear2014 <- CountyDataWithGender %>%
  filter(FinalGender != "bothMissing") %>%
  mutate(AgencyYear = paste0(Agency,"-",Year)) %>%
  group_by(AgencyYear) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  separate(AgencyYear, c("Agency", "Year"), "-") %>%
  #group_by(Agency, Year) %>%
  filter(Year == yearFilter) %>%
  arrange(desc(count)) %>%
  top_n(10)

t <- CountyDataWithGender %>%
  filter(FinalGender != "bothMissing",
         Total.Pay...Benefits < 1e+6 &
           Total.Pay...Benefits > 100) %>%  # there is a person who makes more than one million
  ungroup() %>%
  select(-Year) %>%
  right_join(Top10ByYear2014) %>%
  dplyr::select(Agency, Total.Pay...Benefits,Year, FinalGender) %>%
  filter(Year == yearFilter)

MediansByCountyAndGender <-  t %>% group_by(Agency, FinalGender) %>%
  summarise(median = median(Total.Pay...Benefits)) %>%
  mutate(median = round(median,0))

#ggplot(t) + 
#geom_histogram(mapping = aes(x = Total.Pay...Benefits))  +

ggplot(t, aes(Total.Pay...Benefits, ..count.., fill = FinalGender)) +
  geom_density(position = "stack", size = .25, colour = "black") +
  facet_grid(Agency  ~ FinalGender) +
  geom_vline(data = MediansByCountyAndGender, aes(xintercept=median),
             #alpha = 1/2,
             colour = "orange") +
  geom_text(data = MediansByCountyAndGender, aes(x = median - 16000, y = .7,
                                                 label = paste("Median Total Earnings \n",
                                                               prettyNum(median, big.mark=",")), sep = " "),
            #round(median,1)), 
            size=1, colour="orange", angle = 90) +
  scale_y_continuous(name = "Density estimation") +
  scale_x_continuous(name = "Total Earnings (thousands)",
                     breaks = seq(20000, 900000, 150000),
                     #labels = scales::comma) +
                     labels = c("20", "170", "320", "470", "620", "770")) + 
  # scale_y_continuous(expand = c(0.1, 0)) +
  theme(strip.text.y = element_text(angle = 0),
        axis.text.x = element_text(size = 5, 
                                   angle = 00,
                                   color = "black", 
                                   hjust = 0),
        axis.text.y  = element_text(size = 5, 
                                    angle = 00,
                                    color = "black", 
                                    hjust = 0),
        strip.text.y = element_text(size = 5,
                                    angle = 0),
        legend.position = "top",
        legend.margin = unit(0, "cm"),
        plot.margin = unit(c(0,0,0,0), "cm"))   #T, R, B, L))



```

```{r plotDensityHistogramFill, fig.width = 6, fig.height = 8,  eval=TRUE, include=TRUE, fig.cap= "Tectonic changes are needed to close the gap between total earnings between males and females. For Riverside and San Diego Counties, the highest paid records are female in 2014.", message = FALSE, warning = FALSE, include=TRUE} 

labelColors <- ifelse( MediansByCountyAndGender$FinalGender == "FemaleLikely",
                       "#af8dc3", "#7fbf7b")

labelGender <- paste( MediansByCountyAndGender$FinalGender, "Median",
                      prettyNum(MediansByCountyAndGender$median, big.mark = ","), 
                      sep = " ")

ggplot(t, aes(Total.Pay...Benefits, ..count.., fill = FinalGender)) +
  geom_density(position = "fill", size = .01, colour = "gray") +
  facet_wrap(~Agency , ncol = 2) +
  geom_vline(data = MediansByCountyAndGender, aes(xintercept = median),
             #alpha = 1/2,
             colour = labelColors) +
  geom_text(data = MediansByCountyAndGender, aes(x = median - 12000, y = .5,
                                                 #label = prettyNum(median, big.mark=",")),
                                                 label = labelGender),
            #round(median,1)), 
            size = 1, angle = 90, colour = labelColors) +
  scale_y_continuous(name = "Density estimation") +
  scale_x_continuous(name = "Total Earnings",
                     breaks = seq(20000, 900000, 150000),
                     labels = scales::comma) +
  # scale_y_continuous(expand = c(0.1, 0)) +
  theme(strip.text.y = element_text(angle = 0),
        axis.text.x = element_text(size = 5, 
                                   angle = 00,
                                   color = "black", 
                                   hjust = 0),
        axis.text.y  = element_text(size = 5, 
                                    angle = 00,
                                    color = "black", 
                                    hjust = 0),
        strip.text.y = element_text(size = 5,
                                    angle = 0),
        legend.position = "top",
        legend.margin = unit(0, "cm"),
        plot.margin = unit(c(0,0,0,0), "cm"))   #T, R, B, L))



```

\newpage


```{r descriptionTable, eval = TRUE}

library(Hmisc)

t <- CountyDataWithGender %>%
  # filter (FinalGender !="bothMissing",
  #        Year == 2014) %>%
  ungroup() %>%
  mutate(AboveOrBelowMedianPay = as.factor(AboveOrBelowMedianPay),
         Agency = as.factor(Agency),
         Year = as.factor(Year),
         FinalGender = as.factor(FinalGender),
         `Total Earnings` = Total.Pay...Benefits) %>% 
  # select(Agency, TotalPay = Total.Pay...Benefits ) %>%
  droplevels() #%>%
# sample_n(50000)

DescTableAll <-  summary(Year   ~ FinalGender + `Total Earnings`,
                      data = t, 
                      method = "reverse", 
                      test = T, 
                      continuous = 0)




DescTableMales <-  summary(Year   ~ `Total Earnings`,
                      data = t, 
                      subset = FinalGender == "MaleLikely",
                      method = "reverse", 
                      test = T, 
                      continuous = 0)


DescTableFemales <-  summary(Year   ~ `Total Earnings`,
                      data = t, 
                      subset = FinalGender == "FemaleLikely",
                      method = "reverse", 
                      test = T, 
                      continuous = 0)


# fuction to take the first row of comment from the latex output

mylatex <- function(...) {
  o <- capture.output(latex(...))
  # this will strip /all/ line-only comments; or if you're only
  #  interested in stripping the first such comment you could
  #  adjust accordingly
  o <- grep('^%', o, inv = T, value = T)
  cat(o, sep = '\n')
  }

```


```{r calculatePayRaises}
# select names that repeat once per year
# spread the data
# calc percent incrase



```

\begin{landscape}


```{r whole county vs target area table, results ='asis', message = FALSE, warning = FALSE, eval = TRUE, include = TRUE}

# render the table
options(scipen = 999)

options(digits = 1)
mylatex(DescTableAll, 
         exclude1 = FALSE, 
         npct = 'numerator', 
         npct.size = "footnotesize", 
         what = c('%'), 
         #landscape = TRUE, 
         file = "", 
         long = T, 
         middle.bold = TRUE, 
         longtable = FALSE,
         overall = TRUE, 
         label = "tbl:descTable1",  
         prmsd = TRUE,  
         size = "small", 
         #width.cutoff = 
         caption = "Descriptive statistics by year", 
         caption.loc = 'top',
         where = "!htbp") # col.just=c("l", "p{3in}")

```

\vspace{10mm} %10mm vertical space

```{r TotalEarningsByMalesAndYear, results ='asis', message = FALSE, warning = FALSE, eval = TRUE, include = TRUE}

# render the table
options(scipen = 999)

options(digits = 1)
mylatex(DescTableMales, 
        exclude1 = FALSE, 
        npct = 'numerator', 
        npct.size = "footnotesize", 
        what = c('%'), 
        #landscape = TRUE, 
        file = "", 
        long = T, 
        middle.bold = TRUE, 
        longtable = FALSE,
        overall = TRUE, 
        label = "tbl:descTable1",  
        prmsd = TRUE,  
        size = "small", 
        #width.cutoff = 
        caption = "Descriptive statistics by year for likely males only.", 
        caption.loc = 'top',
        where = "!htbp") # col.just=c("l", "p{3in}")


```

\vspace{10mm} %10mm vertical space


```{r TotalEarningsByFemalesAndYear, results ='asis', message = FALSE, warning = FALSE, eval = TRUE, include = TRUE}

# render the table
options(scipen = 999)

options(digits = 1)
mylatex(DescTableFemales, 
         exclude1 = FALSE, 
         npct = 'numerator', 
         npct.size = "footnotesize", 
         what = c('%'), 
         #landscape = TRUE, 
         file = "", 
         long = T, 
         middle.bold = TRUE, 
         longtable = FALSE,
         overall = TRUE, 
         label = "tbl:descTable1",  
         prmsd = TRUE,  
         size = "small", 
         #width.cutoff = 
         caption = "Descriptive statistics by year for likely females only.", 
         caption.loc = 'top',
         where = "!htbp") # col.just=c("l", "p{3in}")


```



\end{landscape}


```{r TODO, eval= FALSE}

# estimate the age of each person using the name
# http://fivethirtyeight.com/features/how-to-tell-someones-age-when-all-you-know-is-her-name/


```

```{r eval= FALSE}

# plot something like this
#  https://learnr.wordpress.com/2009/03/29/ggplot2_marimekko_mosaic_chart/


ggMMplot <- function(var1, var2){
  require(ggplot2)
  levVar1 <- length(levels(var1))
  levVar2 <- length(levels(var2))

  jointTable <- prop.table(table(var1, var2))
  plotData <- as.data.frame(jointTable)
  plotData$marginVar1 <- prop.table(table(var1))
  plotData$var2Height <- plotData$Freq / plotData$marginVar1
  plotData$var1Center <- c(0, cumsum(plotData$marginVar1)[1:levVar1 -1]) +
    plotData$marginVar1 / 2

  ggplot(plotData, aes(var1Center, var2Height)) +
    geom_bar(stat = "identity", aes(width = marginVar1, fill = var2), col = "Black") +
    geom_text(aes(label = as.character(var1), x = var1Center, y = 1.05)) 
  }

ggMMplot(diamonds$cut, diamonds$clarity)



require(ggplot2)
levVar1 <- length(levels(diamonds$cut))
levVar1
levVar2 <- length(levels(diamonds$clarity))
levVar2

jointTable <- prop.table(table(diamonds$cut, diamonds$clarity))
jointTable
plotData <- as.data.frame(jointTable)
plotData
plotData$marginVar1 <- prop.table(table(diamonds$cut))
plotData
plotData$var2Height <- plotData$Freq / plotData$marginVar1
plotData
plotData$var1Center <- c(0, cumsum(plotData$marginVar1)[1:levVar1 -1]) +
  plotData$marginVar1 / 2
plotData

ggplot(plotData, aes(var1Center, var2Height)) +
  geom_bar(stat = "identity", aes(width = marginVar1, fill = diamonds$clarity), col = "Black") +
  geom_text(aes(label = as.character(diamonds$cut), x = var1Center, y = 1.05)) 
}

ggMMplot(diamonds$cut, diamonds$clarity)







````

------

```{r get the completion time, cache= FALSE}
# get the time
endTime <- Sys.time()

```

The analysis was completed on `r format(Sys.time(), "%A %b %d %X %Y")
` in `r round(difftime(endTime, startTime , units = c( "secs")),0)` seconds. 